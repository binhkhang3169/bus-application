// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.29.0
// source: query.sql

package db

import (
	"context"
	"database/sql"
	"encoding/json"
	"time"

	"github.com/google/uuid"
	"github.com/lib/pq"
)

const areSeatsAvailable = `-- name: AreSeatsAvailable :many
SELECT s.id,
       EXISTS(
           SELECT 1
           FROM seat_tickets st
           WHERE st.seat_id = s.id AND st.status IN (0, 1, 3) -- 0: pending, 1: paid, 3: checked-in
       ) as is_booked
FROM seats s
WHERE s.id = ANY($1::int[])
`

type AreSeatsAvailableRow struct {
	ID       int32 `json:"id"`
	IsBooked bool  `json:"is_booked"`
}

// Checks if a list of seats are available (not booked or held).
func (q *Queries) AreSeatsAvailable(ctx context.Context, seatIds []int32) ([]AreSeatsAvailableRow, error) {
	rows, err := q.db.QueryContext(ctx, areSeatsAvailable, pq.Array(seatIds))
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []AreSeatsAvailableRow{}
	for rows.Next() {
		var i AreSeatsAvailableRow
		if err := rows.Scan(&i.ID, &i.IsBooked); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const createCheckin = `-- name: CreateCheckin :one


INSERT INTO checkins (seat_ticket_id, ticket_id, trip_id, seat_name, note)
VALUES ($1, $2, $3, $4, $5)
RETURNING id, seat_ticket_id, ticket_id, trip_id, seat_name, checked_in_at, note
`

type CreateCheckinParams struct {
	SeatTicketID int32          `json:"seat_ticket_id"`
	TicketID     string         `json:"ticket_id"`
	TripID       string         `json:"trip_id"`
	SeatName     sql.NullString `json:"seat_name"`
	Note         string         `json:"note"`
}

// Typically checkin for confirmed/paid tickets;
// Inserts a new checkin record - can now get trip_id from seat_tickets directly.
func (q *Queries) CreateCheckin(ctx context.Context, arg CreateCheckinParams) (Checkin, error) {
	row := q.db.QueryRowContext(ctx, createCheckin,
		arg.SeatTicketID,
		arg.TicketID,
		arg.TripID,
		arg.SeatName,
		arg.Note,
	)
	var i Checkin
	err := row.Scan(
		&i.ID,
		&i.SeatTicketID,
		&i.TicketID,
		&i.TripID,
		&i.SeatName,
		&i.CheckedInAt,
		&i.Note,
	)
	return i, err
}

const createOutboxEvent = `-- name: CreateOutboxEvent :exec
INSERT INTO outbox_events (id, topic, key, payload)
VALUES ($1, $2, $3, $4)
`

type CreateOutboxEventParams struct {
	ID      uuid.UUID       `json:"id"`
	Topic   string          `json:"topic"`
	Key     string          `json:"key"`
	Payload json.RawMessage `json:"payload"`
}

// For Transactional Outbox Pattern
func (q *Queries) CreateOutboxEvent(ctx context.Context, arg CreateOutboxEventParams) error {
	_, err := q.db.ExecContext(ctx, createOutboxEvent,
		arg.ID,
		arg.Topic,
		arg.Key,
		arg.Payload,
	)
	return err
}

const createSeat = `-- name: CreateSeat :one
INSERT INTO seats (trip_id, seat_name)
VALUES ($1, $2)
RETURNING id, trip_id, seat_name, created_at, updated_at
`

type CreateSeatParams struct {
	TripID   string         `json:"trip_id"`
	SeatName sql.NullString `json:"seat_name"`
}

// Inserts a new seat for a trip.
func (q *Queries) CreateSeat(ctx context.Context, arg CreateSeatParams) (Seat, error) {
	row := q.db.QueryRowContext(ctx, createSeat, arg.TripID, arg.SeatName)
	var i Seat
	err := row.Scan(
		&i.ID,
		&i.TripID,
		&i.SeatName,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const createSeatTicket = `-- name: CreateSeatTicket :one
INSERT INTO seat_tickets (seat_id, ticket_id, status, trip_id)
VALUES ($1, $2, $3, $4)
RETURNING id, seat_id, ticket_id, status, trip_id, created_at, updated_at
`

type CreateSeatTicketParams struct {
	SeatID   int32  `json:"seat_id"`
	TicketID string `json:"ticket_id"`
	Status   int16  `json:"status"`
	TripID   string `json:"trip_id"`
}

// Links a seat to a ticket, now includes trip_id directly.
func (q *Queries) CreateSeatTicket(ctx context.Context, arg CreateSeatTicketParams) (SeatTicket, error) {
	row := q.db.QueryRowContext(ctx, createSeatTicket,
		arg.SeatID,
		arg.TicketID,
		arg.Status,
		arg.TripID,
	)
	var i SeatTicket
	err := row.Scan(
		&i.ID,
		&i.SeatID,
		&i.TicketID,
		&i.Status,
		&i.TripID,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const createTicket = `-- name: CreateTicket :one
INSERT INTO Ticket (
    Ticket_Id, Trip_Id_Begin, Trip_Id_End, Type, Customer_Id, Phone, Email, Name, Price, Status,
    Booking_Time, Payment_Status, Booking_Channel, Policy_Id, Booked_By
) VALUES (
    $1, $2, $3, $4, $5, $6, $7, $8, $9, $10, $11, $12, $13, $14, $15
) RETURNING ticket_id, trip_id_begin, trip_id_end, type, customer_id, phone, email, name, price, status, booking_time, payment_status, booking_channel, created_at, updated_at, policy_id, booked_by
`

type CreateTicketParams struct {
	TicketID       string         `json:"ticket_id"`
	TripIDBegin    string         `json:"trip_id_begin"`
	TripIDEnd      sql.NullString `json:"trip_id_end"`
	Type           int16          `json:"type"`
	CustomerID     sql.NullInt32  `json:"customer_id"`
	Phone          sql.NullString `json:"phone"`
	Email          sql.NullString `json:"email"`
	Name           sql.NullString `json:"name"`
	Price          float64        `json:"price"`
	Status         int16          `json:"status"`
	BookingTime    time.Time      `json:"booking_time"`
	PaymentStatus  int16          `json:"payment_status"`
	BookingChannel int16          `json:"booking_channel"`
	PolicyID       int32          `json:"policy_id"`
	BookedBy       sql.NullString `json:"booked_by"`
}

// Inserts a new ticket record for both one-way and round-trip.
func (q *Queries) CreateTicket(ctx context.Context, arg CreateTicketParams) (Ticket, error) {
	row := q.db.QueryRowContext(ctx, createTicket,
		arg.TicketID,
		arg.TripIDBegin,
		arg.TripIDEnd,
		arg.Type,
		arg.CustomerID,
		arg.Phone,
		arg.Email,
		arg.Name,
		arg.Price,
		arg.Status,
		arg.BookingTime,
		arg.PaymentStatus,
		arg.BookingChannel,
		arg.PolicyID,
		arg.BookedBy,
	)
	var i Ticket
	err := row.Scan(
		&i.TicketID,
		&i.TripIDBegin,
		&i.TripIDEnd,
		&i.Type,
		&i.CustomerID,
		&i.Phone,
		&i.Email,
		&i.Name,
		&i.Price,
		&i.Status,
		&i.BookingTime,
		&i.PaymentStatus,
		&i.BookingChannel,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.PolicyID,
		&i.BookedBy,
	)
	return i, err
}

const createTicketDetails = `-- name: CreateTicketDetails :one
INSERT INTO Ticket_Details (
    Ticket_Id, Pickup_Location_Begin, Dropoff_Location_Begin, Pickup_Location_End, Dropoff_Location_End
) VALUES (
    $1, $2, $3, $4, $5
) RETURNING detail_id, ticket_id, pickup_location_begin, dropoff_location_begin, pickup_location_end, dropoff_location_end, created_at, updated_at
`

type CreateTicketDetailsParams struct {
	TicketID             string        `json:"ticket_id"`
	PickupLocationBegin  sql.NullInt32 `json:"pickup_location_begin"`
	DropoffLocationBegin sql.NullInt32 `json:"dropoff_location_begin"`
	PickupLocationEnd    sql.NullInt32 `json:"pickup_location_end"`
	DropoffLocationEnd   sql.NullInt32 `json:"dropoff_location_end"`
}

// Inserts details for a ticket.
func (q *Queries) CreateTicketDetails(ctx context.Context, arg CreateTicketDetailsParams) (TicketDetail, error) {
	row := q.db.QueryRowContext(ctx, createTicketDetails,
		arg.TicketID,
		arg.PickupLocationBegin,
		arg.DropoffLocationBegin,
		arg.PickupLocationEnd,
		arg.DropoffLocationEnd,
	)
	var i TicketDetail
	err := row.Scan(
		&i.DetailID,
		&i.TicketID,
		&i.PickupLocationBegin,
		&i.DropoffLocationBegin,
		&i.PickupLocationEnd,
		&i.DropoffLocationEnd,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const createTicketLog = `-- name: CreateTicketLog :one
INSERT INTO Ticket_Logs (Ticket_Id, Action)
VALUES ($1, $2)
RETURNING log_id, ticket_id, action, created_at
`

type CreateTicketLogParams struct {
	TicketID string `json:"ticket_id"`
	Action   string `json:"action"`
}

// Inserts a log entry for a ticket action.
func (q *Queries) CreateTicketLog(ctx context.Context, arg CreateTicketLogParams) (TicketLog, error) {
	row := q.db.QueryRowContext(ctx, createTicketLog, arg.TicketID, arg.Action)
	var i TicketLog
	err := row.Scan(
		&i.LogID,
		&i.TicketID,
		&i.Action,
		&i.CreatedAt,
	)
	return i, err
}

const deleteOutboxEvents = `-- name: DeleteOutboxEvents :exec
DELETE FROM outbox_events
WHERE id = ANY($1::uuid[])
`

// For the Outbox Poller/Relay
func (q *Queries) DeleteOutboxEvents(ctx context.Context, eventIds []uuid.UUID) error {
	_, err := q.db.ExecContext(ctx, deleteOutboxEvents, pq.Array(eventIds))
	return err
}

const getAllCheckinsByTripID = `-- name: GetAllCheckinsByTripID :many
SELECT id, seat_ticket_id, ticket_id, trip_id, seat_name, checked_in_at, note FROM checkins
WHERE trip_id = $1
ORDER BY checked_in_at DESC
`

func (q *Queries) GetAllCheckinsByTripID(ctx context.Context, tripID string) ([]Checkin, error) {
	rows, err := q.db.QueryContext(ctx, getAllCheckinsByTripID, tripID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []Checkin{}
	for rows.Next() {
		var i Checkin
		if err := rows.Scan(
			&i.ID,
			&i.SeatTicketID,
			&i.TicketID,
			&i.TripID,
			&i.SeatName,
			&i.CheckedInAt,
			&i.Note,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getAllTickets = `-- name: GetAllTickets :many
SELECT ticket_id, trip_id_begin, trip_id_end, type, customer_id, phone, email, name, price, status, booking_time, payment_status, booking_channel, created_at, updated_at, policy_id, booked_by FROM Ticket
ORDER BY Booking_Time DESC
LIMIT $1
OFFSET $2
`

type GetAllTicketsParams struct {
	Limit  int32 `json:"limit"`
	Offset int32 `json:"offset"`
}

// Retrieves a paginated list of all tickets, ordered by booking time.
func (q *Queries) GetAllTickets(ctx context.Context, arg GetAllTicketsParams) ([]Ticket, error) {
	rows, err := q.db.QueryContext(ctx, getAllTickets, arg.Limit, arg.Offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []Ticket{}
	for rows.Next() {
		var i Ticket
		if err := rows.Scan(
			&i.TicketID,
			&i.TripIDBegin,
			&i.TripIDEnd,
			&i.Type,
			&i.CustomerID,
			&i.Phone,
			&i.Email,
			&i.Name,
			&i.Price,
			&i.Status,
			&i.BookingTime,
			&i.PaymentStatus,
			&i.BookingChannel,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.PolicyID,
			&i.BookedBy,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getOutboxEvents = `-- name: GetOutboxEvents :many
SELECT id, topic, key, payload, created_at FROM outbox_events
ORDER BY created_at
LIMIT $1
`

// For the Outbox Poller/Relay
func (q *Queries) GetOutboxEvents(ctx context.Context, limit int32) ([]OutboxEvent, error) {
	rows, err := q.db.QueryContext(ctx, getOutboxEvents, limit)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []OutboxEvent{}
	for rows.Next() {
		var i OutboxEvent
		if err := rows.Scan(
			&i.ID,
			&i.Topic,
			&i.Key,
			&i.Payload,
			&i.CreatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getSeatByID = `-- name: GetSeatByID :one
SELECT id, trip_id, seat_name, created_at, updated_at FROM seats
WHERE id = $1
`

// Retrieves a specific seat by its ID.
func (q *Queries) GetSeatByID(ctx context.Context, id int32) (Seat, error) {
	row := q.db.QueryRowContext(ctx, getSeatByID, id)
	var i Seat
	err := row.Scan(
		&i.ID,
		&i.TripID,
		&i.SeatName,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const getSeatIDsByTicketID = `-- name: GetSeatIDsByTicketID :many
SELECT seat_id FROM seat_tickets
WHERE ticket_id = $1
`

// Retrieves seat_ids associated with a ticket_id.
func (q *Queries) GetSeatIDsByTicketID(ctx context.Context, ticketID string) ([]int32, error) {
	rows, err := q.db.QueryContext(ctx, getSeatIDsByTicketID, ticketID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []int32{}
	for rows.Next() {
		var seat_id int32
		if err := rows.Scan(&seat_id); err != nil {
			return nil, err
		}
		items = append(items, seat_id)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getSeatTicketAndSeatInfoByTicketID = `-- name: GetSeatTicketAndSeatInfoByTicketID :one
SELECT
    st.id as seat_ticket_id, st.seat_id, st.ticket_id, st.status as seat_ticket_status, st.trip_id,
    s.id as seat_table_id, s.seat_name
FROM seat_tickets st
JOIN seats s ON st.seat_id = s.id
WHERE st.ticket_id = $1 AND st.status = 1
`

type GetSeatTicketAndSeatInfoByTicketIDRow struct {
	SeatTicketID     int32          `json:"seat_ticket_id"`
	SeatID           int32          `json:"seat_id"`
	TicketID         string         `json:"ticket_id"`
	SeatTicketStatus int16          `json:"seat_ticket_status"`
	TripID           string         `json:"trip_id"`
	SeatTableID      int32          `json:"seat_table_id"`
	SeatName         sql.NullString `json:"seat_name"`
}

// Retrieves seat_ticket and associated seat details for a given ticket_id.
func (q *Queries) GetSeatTicketAndSeatInfoByTicketID(ctx context.Context, ticketID string) (GetSeatTicketAndSeatInfoByTicketIDRow, error) {
	row := q.db.QueryRowContext(ctx, getSeatTicketAndSeatInfoByTicketID, ticketID)
	var i GetSeatTicketAndSeatInfoByTicketIDRow
	err := row.Scan(
		&i.SeatTicketID,
		&i.SeatID,
		&i.TicketID,
		&i.SeatTicketStatus,
		&i.TripID,
		&i.SeatTableID,
		&i.SeatName,
	)
	return i, err
}

const getSeatTicketByID = `-- name: GetSeatTicketByID :one

SELECT st.id, st.seat_id, st.ticket_id, st.status, st.trip_id, st.created_at, st.updated_at, s.seat_name
FROM seat_tickets st
JOIN seats s ON st.seat_id = s.id
WHERE st.seat_id = $1 and st.ticket_id = $2 and st.status  = 1
`

type GetSeatTicketByIDParams struct {
	SeatID   int32  `json:"seat_id"`
	TicketID string `json:"ticket_id"`
}

type GetSeatTicketByIDRow struct {
	ID        int32          `json:"id"`
	SeatID    int32          `json:"seat_id"`
	TicketID  string         `json:"ticket_id"`
	Status    int16          `json:"status"`
	TripID    string         `json:"trip_id"`
	CreatedAt sql.NullTime   `json:"created_at"`
	UpdatedAt sql.NullTime   `json:"updated_at"`
	SeatName  sql.NullString `json:"seat_name"`
}

// Typically checkin for confirmed/paid tickets
// Retrieves a specific seat_ticket by its ID - now uses trip_id directly.
func (q *Queries) GetSeatTicketByID(ctx context.Context, arg GetSeatTicketByIDParams) (GetSeatTicketByIDRow, error) {
	row := q.db.QueryRowContext(ctx, getSeatTicketByID, arg.SeatID, arg.TicketID)
	var i GetSeatTicketByIDRow
	err := row.Scan(
		&i.ID,
		&i.SeatID,
		&i.TicketID,
		&i.Status,
		&i.TripID,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.SeatName,
	)
	return i, err
}

const getSeatTicketStatus = `-- name: GetSeatTicketStatus :one
SELECT status FROM seat_tickets
WHERE id = $1
`

// Retrieves just the status of a seat_ticket.
func (q *Queries) GetSeatTicketStatus(ctx context.Context, id int32) (int16, error) {
	row := q.db.QueryRowContext(ctx, getSeatTicketStatus, id)
	var status int16
	err := row.Scan(&status)
	return status, err
}

const getSeatTicketsByTicketID = `-- name: GetSeatTicketsByTicketID :many
SELECT st.id, st.seat_id, st.ticket_id, st.status, st.trip_id, st.created_at, st.updated_at, s.seat_name
FROM seat_tickets st
JOIN seats s ON st.seat_id = s.id
WHERE st.ticket_id = $1
`

type GetSeatTicketsByTicketIDRow struct {
	ID        int32          `json:"id"`
	SeatID    int32          `json:"seat_id"`
	TicketID  string         `json:"ticket_id"`
	Status    int16          `json:"status"`
	TripID    string         `json:"trip_id"`
	CreatedAt sql.NullTime   `json:"created_at"`
	UpdatedAt sql.NullTime   `json:"updated_at"`
	SeatName  sql.NullString `json:"seat_name"`
}

// Retrieves all seat_ticket entries for a given Ticket_Id, no longer needs JOIN with seats.
func (q *Queries) GetSeatTicketsByTicketID(ctx context.Context, ticketID string) ([]GetSeatTicketsByTicketIDRow, error) {
	rows, err := q.db.QueryContext(ctx, getSeatTicketsByTicketID, ticketID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []GetSeatTicketsByTicketIDRow{}
	for rows.Next() {
		var i GetSeatTicketsByTicketIDRow
		if err := rows.Scan(
			&i.ID,
			&i.SeatID,
			&i.TicketID,
			&i.Status,
			&i.TripID,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.SeatName,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getSeatTicketsByTicketIDs = `-- name: GetSeatTicketsByTicketIDs :many
SELECT st.id, st.seat_id, st.ticket_id, st.status, st.trip_id, st.created_at, st.updated_at, s.seat_name
FROM seat_tickets st
JOIN seats s ON st.seat_id = s.id
WHERE st.ticket_id = ANY($1::varchar[])
`

type GetSeatTicketsByTicketIDsRow struct {
	ID        int32          `json:"id"`
	SeatID    int32          `json:"seat_id"`
	TicketID  string         `json:"ticket_id"`
	Status    int16          `json:"status"`
	TripID    string         `json:"trip_id"`
	CreatedAt sql.NullTime   `json:"created_at"`
	UpdatedAt sql.NullTime   `json:"updated_at"`
	SeatName  sql.NullString `json:"seat_name"`
}

// Retrieves all seat_ticket entries for a given list of Ticket_Ids.
func (q *Queries) GetSeatTicketsByTicketIDs(ctx context.Context, ticketIds []string) ([]GetSeatTicketsByTicketIDsRow, error) {
	rows, err := q.db.QueryContext(ctx, getSeatTicketsByTicketIDs, pq.Array(ticketIds))
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []GetSeatTicketsByTicketIDsRow{}
	for rows.Next() {
		var i GetSeatTicketsByTicketIDsRow
		if err := rows.Scan(
			&i.ID,
			&i.SeatID,
			&i.TicketID,
			&i.Status,
			&i.TripID,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.SeatName,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getSeatsByTripID = `-- name: GetSeatsByTripID :many
SELECT id, trip_id, seat_name, created_at, updated_at FROM seats
WHERE trip_id = $1
ORDER BY seat_name
`

// Retrieves all seats for a given trip_id.
func (q *Queries) GetSeatsByTripID(ctx context.Context, tripID string) ([]Seat, error) {
	rows, err := q.db.QueryContext(ctx, getSeatsByTripID, tripID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []Seat{}
	for rows.Next() {
		var i Seat
		if err := rows.Scan(
			&i.ID,
			&i.TripID,
			&i.SeatName,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getTicketByPhoneAndIDCore = `-- name: GetTicketByPhoneAndIDCore :one
SELECT ticket_id, trip_id_begin, trip_id_end, type, customer_id, phone, email, name, price, status, booking_time, payment_status, booking_channel, created_at, updated_at, policy_id, booked_by FROM Ticket
WHERE Ticket_Id = $1 AND Phone = $2
`

type GetTicketByPhoneAndIDCoreParams struct {
	TicketID string         `json:"ticket_id"`
	Phone    sql.NullString `json:"phone"`
}

// Retrieves core ticket information by Ticket_Id and Phone.
func (q *Queries) GetTicketByPhoneAndIDCore(ctx context.Context, arg GetTicketByPhoneAndIDCoreParams) (Ticket, error) {
	row := q.db.QueryRowContext(ctx, getTicketByPhoneAndIDCore, arg.TicketID, arg.Phone)
	var i Ticket
	err := row.Scan(
		&i.TicketID,
		&i.TripIDBegin,
		&i.TripIDEnd,
		&i.Type,
		&i.CustomerID,
		&i.Phone,
		&i.Email,
		&i.Name,
		&i.Price,
		&i.Status,
		&i.BookingTime,
		&i.PaymentStatus,
		&i.BookingChannel,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.PolicyID,
		&i.BookedBy,
	)
	return i, err
}

const getTicketCore = `-- name: GetTicketCore :one
SELECT ticket_id, trip_id_begin, trip_id_end, type, customer_id, phone, email, name, price, status, booking_time, payment_status, booking_channel, created_at, updated_at, policy_id, booked_by FROM Ticket
WHERE Ticket_Id = $1
`

// Retrieves core ticket information by Ticket_Id.
func (q *Queries) GetTicketCore(ctx context.Context, ticketID string) (Ticket, error) {
	row := q.db.QueryRowContext(ctx, getTicketCore, ticketID)
	var i Ticket
	err := row.Scan(
		&i.TicketID,
		&i.TripIDBegin,
		&i.TripIDEnd,
		&i.Type,
		&i.CustomerID,
		&i.Phone,
		&i.Email,
		&i.Name,
		&i.Price,
		&i.Status,
		&i.BookingTime,
		&i.PaymentStatus,
		&i.BookingChannel,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.PolicyID,
		&i.BookedBy,
	)
	return i, err
}

const getTicketDetailsByTicketID = `-- name: GetTicketDetailsByTicketID :many
SELECT detail_id, ticket_id, pickup_location_begin, dropoff_location_begin, pickup_location_end, dropoff_location_end, created_at, updated_at FROM Ticket_Details
WHERE Ticket_Id = $1
`

// Retrieves all details for a given Ticket_Id.
func (q *Queries) GetTicketDetailsByTicketID(ctx context.Context, ticketID string) ([]TicketDetail, error) {
	rows, err := q.db.QueryContext(ctx, getTicketDetailsByTicketID, ticketID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []TicketDetail{}
	for rows.Next() {
		var i TicketDetail
		if err := rows.Scan(
			&i.DetailID,
			&i.TicketID,
			&i.PickupLocationBegin,
			&i.DropoffLocationBegin,
			&i.PickupLocationEnd,
			&i.DropoffLocationEnd,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getTicketDetailsByTicketIDs = `-- name: GetTicketDetailsByTicketIDs :many
SELECT detail_id, ticket_id, pickup_location_begin, dropoff_location_begin, pickup_location_end, dropoff_location_end, created_at, updated_at FROM Ticket_Details
WHERE Ticket_Id = ANY($1::varchar[])
`

// Retrieves all details for a given list of Ticket_Ids.
func (q *Queries) GetTicketDetailsByTicketIDs(ctx context.Context, ticketIds []string) ([]TicketDetail, error) {
	rows, err := q.db.QueryContext(ctx, getTicketDetailsByTicketIDs, pq.Array(ticketIds))
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []TicketDetail{}
	for rows.Next() {
		var i TicketDetail
		if err := rows.Scan(
			&i.DetailID,
			&i.TicketID,
			&i.PickupLocationBegin,
			&i.DropoffLocationBegin,
			&i.PickupLocationEnd,
			&i.DropoffLocationEnd,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getTicketStatus = `-- name: GetTicketStatus :one
SELECT status FROM Ticket
WHERE Ticket_Id = $1
`

// Retrieves just the status of a ticket.
func (q *Queries) GetTicketStatus(ctx context.Context, ticketID string) (int16, error) {
	row := q.db.QueryRowContext(ctx, getTicketStatus, ticketID)
	var status int16
	err := row.Scan(&status)
	return status, err
}

const getTicketsByCustomerIDCore = `-- name: GetTicketsByCustomerIDCore :many
SELECT ticket_id, trip_id_begin, trip_id_end, type, customer_id, phone, email, name, price, status, booking_time, payment_status, booking_channel, created_at, updated_at, policy_id, booked_by FROM Ticket
WHERE Customer_Id = $1
ORDER BY Booking_Time DESC
`

// Retrieves all core ticket information for a given Customer_Id.
func (q *Queries) GetTicketsByCustomerIDCore(ctx context.Context, customerID sql.NullInt32) ([]Ticket, error) {
	rows, err := q.db.QueryContext(ctx, getTicketsByCustomerIDCore, customerID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []Ticket{}
	for rows.Next() {
		var i Ticket
		if err := rows.Scan(
			&i.TicketID,
			&i.TripIDBegin,
			&i.TripIDEnd,
			&i.Type,
			&i.CustomerID,
			&i.Phone,
			&i.Email,
			&i.Name,
			&i.Price,
			&i.Status,
			&i.BookingTime,
			&i.PaymentStatus,
			&i.BookingChannel,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.PolicyID,
			&i.BookedBy,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getTotalTicketCount = `-- name: GetTotalTicketCount :one
SELECT COUNT(*) FROM Ticket
`

// Retrieves the total number of tickets.
func (q *Queries) GetTotalTicketCount(ctx context.Context) (int64, error) {
	row := q.db.QueryRowContext(ctx, getTotalTicketCount)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const isSeatBookedOnTrip = `-- name: IsSeatBookedOnTrip :one
SELECT EXISTS (
    SELECT 1
    FROM seat_tickets st
    WHERE st.seat_id = $1 AND st.trip_id = $2 AND st.status IN (0, 1)
)
`

type IsSeatBookedOnTripParams struct {
	SeatID int32  `json:"seat_id"`
	TripID string `json:"trip_id"`
}

// Checks if a specific seat_id is booked on a specific trip - now uses trip_id directly.
func (q *Queries) IsSeatBookedOnTrip(ctx context.Context, arg IsSeatBookedOnTripParams) (bool, error) {
	row := q.db.QueryRowContext(ctx, isSeatBookedOnTrip, arg.SeatID, arg.TripID)
	var exists bool
	err := row.Scan(&exists)
	return exists, err
}

const isSeatGenerallyBooked = `-- name: IsSeatGenerallyBooked :one
SELECT EXISTS (
    SELECT 1
    FROM seat_tickets
    WHERE seat_id = $1 AND status IN (0, 1)
)
`

// Checks if a specific seat_id is currently booked or pending (status 0 or 1).
func (q *Queries) IsSeatGenerallyBooked(ctx context.Context, seatID int32) (bool, error) {
	row := q.db.QueryRowContext(ctx, isSeatGenerallyBooked, seatID)
	var exists bool
	err := row.Scan(&exists)
	return exists, err
}

const listAvailableSeatsByTripID = `-- name: ListAvailableSeatsByTripID :many
SELECT s.id, s.trip_id, s.seat_name
FROM seats s
WHERE s.trip_id = $1
AND NOT EXISTS (
    SELECT 1
    FROM seat_tickets st
    WHERE st.seat_id = s.id AND st.status IN (0, 1, 3) -- 0: pending, 1: paid, 3: checked-in
)
ORDER BY s.seat_name
`

type ListAvailableSeatsByTripIDRow struct {
	ID       int32          `json:"id"`
	TripID   string         `json:"trip_id"`
	SeatName sql.NullString `json:"seat_name"`
}

// Lists all seats for a trip_id that are not in seat_tickets or have status 2 (cancelled).
func (q *Queries) ListAvailableSeatsByTripID(ctx context.Context, tripID string) ([]ListAvailableSeatsByTripIDRow, error) {
	rows, err := q.db.QueryContext(ctx, listAvailableSeatsByTripID, tripID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []ListAvailableSeatsByTripIDRow{}
	for rows.Next() {
		var i ListAvailableSeatsByTripIDRow
		if err := rows.Scan(&i.ID, &i.TripID, &i.SeatName); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const updateSeatTicketStatus = `-- name: UpdateSeatTicketStatus :one
UPDATE seat_tickets
SET status = $2, updated_at = CURRENT_TIMESTAMP
WHERE id = $1
RETURNING id, seat_id, ticket_id, status, trip_id, created_at, updated_at
`

type UpdateSeatTicketStatusParams struct {
	ID     int32 `json:"id"`
	Status int16 `json:"status"`
}

// Updates the status of a seat_ticket entry by its ID.
func (q *Queries) UpdateSeatTicketStatus(ctx context.Context, arg UpdateSeatTicketStatusParams) (SeatTicket, error) {
	row := q.db.QueryRowContext(ctx, updateSeatTicketStatus, arg.ID, arg.Status)
	var i SeatTicket
	err := row.Scan(
		&i.ID,
		&i.SeatID,
		&i.TicketID,
		&i.Status,
		&i.TripID,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const updateSeatTicketStatusAfterCheckin = `-- name: UpdateSeatTicketStatusAfterCheckin :one
UPDATE seat_tickets
SET status = $2, updated_at = CURRENT_TIMESTAMP -- $2 would be the 'checked-in' status
WHERE id = $1 -- seat_ticket.id
RETURNING id, seat_id, ticket_id, status, trip_id, created_at, updated_at
`

type UpdateSeatTicketStatusAfterCheckinParams struct {
	ID     int32 `json:"id"`
	Status int16 `json:"status"`
}

// Updates the seat_ticket status to 'checked-in'.
func (q *Queries) UpdateSeatTicketStatusAfterCheckin(ctx context.Context, arg UpdateSeatTicketStatusAfterCheckinParams) (SeatTicket, error) {
	row := q.db.QueryRowContext(ctx, updateSeatTicketStatusAfterCheckin, arg.ID, arg.Status)
	var i SeatTicket
	err := row.Scan(
		&i.ID,
		&i.SeatID,
		&i.TicketID,
		&i.Status,
		&i.TripID,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const updateSeatTicketStatusByTicketID = `-- name: UpdateSeatTicketStatusByTicketID :many
UPDATE seat_tickets
SET status = $2, updated_at = CURRENT_TIMESTAMP
WHERE ticket_id = $1
RETURNING id, seat_id, ticket_id, status, trip_id, created_at, updated_at
`

type UpdateSeatTicketStatusByTicketIDParams struct {
	TicketID string `json:"ticket_id"`
	Status   int16  `json:"status"`
}

// Updates the status of all seat_ticket entries for a given ticket_id.
func (q *Queries) UpdateSeatTicketStatusByTicketID(ctx context.Context, arg UpdateSeatTicketStatusByTicketIDParams) ([]SeatTicket, error) {
	rows, err := q.db.QueryContext(ctx, updateSeatTicketStatusByTicketID, arg.TicketID, arg.Status)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []SeatTicket{}
	for rows.Next() {
		var i SeatTicket
		if err := rows.Scan(
			&i.ID,
			&i.SeatID,
			&i.TicketID,
			&i.Status,
			&i.TripID,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const updateTicketPaymentStatus = `-- name: UpdateTicketPaymentStatus :one
UPDATE Ticket
SET Payment_Status = $2, Status = $3, Updated_At = CURRENT_TIMESTAMP
WHERE Ticket_Id = $1
RETURNING ticket_id, trip_id_begin, trip_id_end, type, customer_id, phone, email, name, price, status, booking_time, payment_status, booking_channel, created_at, updated_at, policy_id, booked_by
`

type UpdateTicketPaymentStatusParams struct {
	TicketID      string `json:"ticket_id"`
	PaymentStatus int16  `json:"payment_status"`
	Status        int16  `json:"status"`
}

// Updates the payment_status and general status of a ticket.
func (q *Queries) UpdateTicketPaymentStatus(ctx context.Context, arg UpdateTicketPaymentStatusParams) (Ticket, error) {
	row := q.db.QueryRowContext(ctx, updateTicketPaymentStatus, arg.TicketID, arg.PaymentStatus, arg.Status)
	var i Ticket
	err := row.Scan(
		&i.TicketID,
		&i.TripIDBegin,
		&i.TripIDEnd,
		&i.Type,
		&i.CustomerID,
		&i.Phone,
		&i.Email,
		&i.Name,
		&i.Price,
		&i.Status,
		&i.BookingTime,
		&i.PaymentStatus,
		&i.BookingChannel,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.PolicyID,
		&i.BookedBy,
	)
	return i, err
}

const updateTicketStatus = `-- name: UpdateTicketStatus :one
UPDATE Ticket
SET Status = $2, Updated_At = CURRENT_TIMESTAMP
WHERE Ticket_Id = $1
RETURNING ticket_id, trip_id_begin, trip_id_end, type, customer_id, phone, email, name, price, status, booking_time, payment_status, booking_channel, created_at, updated_at, policy_id, booked_by
`

type UpdateTicketStatusParams struct {
	TicketID string `json:"ticket_id"`
	Status   int16  `json:"status"`
}

// Updates the status of a ticket.
func (q *Queries) UpdateTicketStatus(ctx context.Context, arg UpdateTicketStatusParams) (Ticket, error) {
	row := q.db.QueryRowContext(ctx, updateTicketStatus, arg.TicketID, arg.Status)
	var i Ticket
	err := row.Scan(
		&i.TicketID,
		&i.TripIDBegin,
		&i.TripIDEnd,
		&i.Type,
		&i.CustomerID,
		&i.Phone,
		&i.Email,
		&i.Name,
		&i.Price,
		&i.Status,
		&i.BookingTime,
		&i.PaymentStatus,
		&i.BookingChannel,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.PolicyID,
		&i.BookedBy,
	)
	return i, err
}

const updateTicketStatusAfterCheckin = `-- name: UpdateTicketStatusAfterCheckin :one
UPDATE Ticket
SET Status = $2, Updated_At = CURRENT_TIMESTAMP -- $2 would be the 'used' status
WHERE Ticket_Id = $1
RETURNING ticket_id, trip_id_begin, trip_id_end, type, customer_id, phone, email, name, price, status, booking_time, payment_status, booking_channel, created_at, updated_at, policy_id, booked_by
`

type UpdateTicketStatusAfterCheckinParams struct {
	TicketID string `json:"ticket_id"`
	Status   int16  `json:"status"`
}

// Updates the ticket's main status to 'used'.
func (q *Queries) UpdateTicketStatusAfterCheckin(ctx context.Context, arg UpdateTicketStatusAfterCheckinParams) (Ticket, error) {
	row := q.db.QueryRowContext(ctx, updateTicketStatusAfterCheckin, arg.TicketID, arg.Status)
	var i Ticket
	err := row.Scan(
		&i.TicketID,
		&i.TripIDBegin,
		&i.TripIDEnd,
		&i.Type,
		&i.CustomerID,
		&i.Phone,
		&i.Email,
		&i.Name,
		&i.Price,
		&i.Status,
		&i.BookingTime,
		&i.PaymentStatus,
		&i.BookingChannel,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.PolicyID,
		&i.BookedBy,
	)
	return i, err
}
